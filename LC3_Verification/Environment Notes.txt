For the Project you do not need to model the memory. The instructions will be generated by the testbench randomly and driven into the DUT . There is also no need to model the Data memory. 
------------------------------------------------------
Probably you know by now, but i want to inform you that you can't use the Student Edition of Modelsim to code your project. you have to log in to grendel.ece.ncsu.edu and use the licensed software. 

Also a small tip that will help you a great deal in coding your project, whenever you are confused about how your scoreboard should behave against some kind of inputs , just simulate the clean DUT and observe the outputs through the waveform, and you will know exactly how the DUT is behaving

------------------------------------------------------
Here are few things i want to say about the project.

1- As we said before, don't let 2 control instructions or 2 memory instructions in you pipeline at the same time, meaning when you send a branch instructions for example , make sure that you follow it with at least 6 instructions that are not a control instruction (JMP, BR).

2- it is important to keep both signals ( complete_instr , complete_data ) high thoughout your simulation ( don't test the behavior when they are low , just keep them high always).

3- the register bank R0-R7 has the values (XXXXX) at the beginning of your simulation. so you need to send series of AND instructions to initialize them to zero at the beginning of your simulation.

AND R0,R0,#0
AND R1,R1,#0
.
.
.
AND R7,R7,#0 

then you can generate whatever instructions you want to send. 

--------------------------------------------------------
 In response a number of question regarding the structure of the testbench here are a few suggestions
 We expect you to get started on building the functional verification testbench first. 
Generator: For exercising the DUT, you are only allowed to send in signals from the Top Level of the DUT. Please do not try to send in signals to the individuals blocks separately. All the signals that are input to each of the 6 blocks are generated internally as outputs from other blocks. The only exception is the input signals at the top level of the LC3, i.e. Instr_dout, complete_instr, complete_insr, Data_dout. Moreover, it is fine to keep complete_data as tied to 1 all the time. As you will see, this means that data is always available on the Data_dout line when required by the DUT. 
Scoreboard: To make your task easier and build a clean testbench, we would suggest you build check functions for each block separately as a different function. In the checker, you can probe the internal signals that are input to a particular block and use them to generate the check signals to compare against the output signals for that block. This approach means that you do not have to worry about designing the pipeline yourself and worry about the timing of signals propagating within your testbench. Note: Over here, we only want you to probe the internal signals. As I said, you are not allowed to modify these signals in any way. 

 Do's and Dont's: 
a) You will see from the design document that some of the Memory and Control Instructions are very complex in nature. In this project, we expect you to send in only one Memory or Control Signal at a time. Please avoid sending in multiple Control or Memory instructions in sequence. 
b) Please avoid sending in invalid inputs to the DUT and checking for unintended behavior. We only expect you to design your Checker for valid inputs to be sent into the DUT. 


